-- Question Packs: Store personalized clarity session question sets per client
-- Generated by buildDeepDiveQuestionSet, reviewed and optionally customized by admin

CREATE TABLE IF NOT EXISTS public.question_packs (
  id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
  client_id uuid NOT NULL REFERENCES public.clients(id) ON DELETE CASCADE,
  questions jsonb NOT NULL,        -- Array of ClarityQuestion objects
  pack_meta jsonb NOT NULL,        -- PackMeta from deepDiveBuilder
  status text NOT NULL DEFAULT 'draft' CHECK (status IN ('draft', 'shipped', 'custom')),
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now(),
  UNIQUE(client_id)
);

-- RLS: deny direct access, use SECURITY DEFINER RPCs
ALTER TABLE public.question_packs ENABLE ROW LEVEL SECURITY;

-- ─── Save or update a question pack (admin) ───────────────────────
CREATE OR REPLACE FUNCTION public.admin_save_question_pack(
  p_client_id uuid,
  p_questions jsonb,
  p_pack_meta jsonb,
  p_status text DEFAULT 'draft'
)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  INSERT INTO question_packs (client_id, questions, pack_meta, status, updated_at)
  VALUES (p_client_id, p_questions, p_pack_meta, p_status, now())
  ON CONFLICT (client_id)
  DO UPDATE SET questions = EXCLUDED.questions,
               pack_meta = EXCLUDED.pack_meta,
               status = EXCLUDED.status,
               updated_at = now();
END;
$$;

GRANT EXECUTE ON FUNCTION public.admin_save_question_pack(uuid, jsonb, jsonb, text) TO anon;
GRANT EXECUTE ON FUNCTION public.admin_save_question_pack(uuid, jsonb, jsonb, text) TO authenticated;

-- ─── Fetch question pack for a client (admin) ────────────────────
CREATE OR REPLACE FUNCTION public.admin_get_question_pack(p_client_id uuid)
RETURNS json
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  result json;
BEGIN
  SELECT row_to_json(t)
  INTO result
  FROM (
    SELECT questions, pack_meta, status, updated_at
    FROM question_packs
    WHERE client_id = p_client_id
  ) t;

  RETURN result;
END;
$$;

GRANT EXECUTE ON FUNCTION public.admin_get_question_pack(uuid) TO anon;
GRANT EXECUTE ON FUNCTION public.admin_get_question_pack(uuid) TO authenticated;

-- ─── Fetch question pack status by email (client Dashboard) ──────
CREATE OR REPLACE FUNCTION public.get_question_pack_status(p_email text)
RETURNS text
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_status text;
BEGIN
  SELECT qp.status
  INTO v_status
  FROM question_packs qp
  JOIN clients c ON c.id = qp.client_id
  WHERE c.email = lower(p_email);

  RETURN COALESCE(v_status, 'none');
END;
$$;

GRANT EXECUTE ON FUNCTION public.get_question_pack_status(text) TO anon;
GRANT EXECUTE ON FUNCTION public.get_question_pack_status(text) TO authenticated;

-- ─── Fetch shipped question pack by email (client clarity session) ─
CREATE OR REPLACE FUNCTION public.get_shipped_question_pack(p_email text)
RETURNS json
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  result json;
BEGIN
  SELECT row_to_json(t)
  INTO result
  FROM (
    SELECT questions, pack_meta
    FROM question_packs qp
    JOIN clients c ON c.id = qp.client_id
    WHERE c.email = lower(p_email)
    AND qp.status IN ('shipped', 'custom')
  ) t;

  RETURN result;
END;
$$;

GRANT EXECUTE ON FUNCTION public.get_shipped_question_pack(text) TO anon;
GRANT EXECUTE ON FUNCTION public.get_shipped_question_pack(text) TO authenticated;
